declare class BaseAPIClient {
    private headers;
    private baseUrl;
    constructor(headers: object, baseUrl: string);
    private buildParams;
    private fetch;
    private request;
    private requestText;
    postRequest<T>(path: string, body?: unknown): Promise<T>;
    putRequest<T>(path: string, body?: unknown): Promise<T>;
    deleteRequest<T>(path: string, body?: unknown): Promise<T>;
    getRequest<T>(path: string, params?: unknown): Promise<T>;
    getText(path: string, params?: unknown): Promise<string>;
}

declare const Skill: {
    readonly OVERALL: "overall";
    readonly ATTACK: "attack";
    readonly DEFENCE: "defence";
    readonly STRENGTH: "strength";
    readonly HITPOINTS: "hitpoints";
    readonly RANGED: "ranged";
    readonly PRAYER: "prayer";
    readonly MAGIC: "magic";
    readonly COOKING: "cooking";
    readonly WOODCUTTING: "woodcutting";
    readonly FLETCHING: "fletching";
    readonly FISHING: "fishing";
    readonly FIREMAKING: "firemaking";
    readonly CRAFTING: "crafting";
    readonly SMITHING: "smithing";
    readonly MINING: "mining";
    readonly HERBLORE: "herblore";
    readonly AGILITY: "agility";
    readonly THIEVING: "thieving";
    readonly SLAYER: "slayer";
    readonly FARMING: "farming";
    readonly RUNECRAFTING: "runecrafting";
    readonly HUNTER: "hunter";
    readonly CONSTRUCTION: "construction";
};
type Skill = (typeof Skill)[keyof typeof Skill];
declare const Activity: {
    readonly LEAGUE_POINTS: "league_points";
    readonly BOUNTY_HUNTER_HUNTER: "bounty_hunter_hunter";
    readonly BOUNTY_HUNTER_ROGUE: "bounty_hunter_rogue";
    readonly CLUE_SCROLLS_ALL: "clue_scrolls_all";
    readonly CLUE_SCROLLS_BEGINNER: "clue_scrolls_beginner";
    readonly CLUE_SCROLLS_EASY: "clue_scrolls_easy";
    readonly CLUE_SCROLLS_MEDIUM: "clue_scrolls_medium";
    readonly CLUE_SCROLLS_HARD: "clue_scrolls_hard";
    readonly CLUE_SCROLLS_ELITE: "clue_scrolls_elite";
    readonly CLUE_SCROLLS_MASTER: "clue_scrolls_master";
    readonly LAST_MAN_STANDING: "last_man_standing";
    readonly PVP_ARENA: "pvp_arena";
    readonly SOUL_WARS_ZEAL: "soul_wars_zeal";
    readonly GUARDIANS_OF_THE_RIFT: "guardians_of_the_rift";
    readonly COLOSSEUM_GLORY: "colosseum_glory";
    readonly COLLECTIONS_LOGGED: "collections_logged";
};
type Activity = (typeof Activity)[keyof typeof Activity];
declare const Boss: {
    readonly ABYSSAL_SIRE: "abyssal_sire";
    readonly ALCHEMICAL_HYDRA: "alchemical_hydra";
    readonly AMOXLIATL: "amoxliatl";
    readonly ARAXXOR: "araxxor";
    readonly ARTIO: "artio";
    readonly BARROWS_CHESTS: "barrows_chests";
    readonly BRYOPHYTA: "bryophyta";
    readonly CALLISTO: "callisto";
    readonly CALVARION: "calvarion";
    readonly CERBERUS: "cerberus";
    readonly CHAMBERS_OF_XERIC: "chambers_of_xeric";
    readonly CHAMBERS_OF_XERIC_CM: "chambers_of_xeric_challenge_mode";
    readonly CHAOS_ELEMENTAL: "chaos_elemental";
    readonly CHAOS_FANATIC: "chaos_fanatic";
    readonly COMMANDER_ZILYANA: "commander_zilyana";
    readonly CORPOREAL_BEAST: "corporeal_beast";
    readonly CRAZY_ARCHAEOLOGIST: "crazy_archaeologist";
    readonly DAGANNOTH_PRIME: "dagannoth_prime";
    readonly DAGANNOTH_REX: "dagannoth_rex";
    readonly DAGANNOTH_SUPREME: "dagannoth_supreme";
    readonly DERANGED_ARCHAEOLOGIST: "deranged_archaeologist";
    readonly DOOM_OF_MOKHAIOTL: "doom_of_mokhaiotl";
    readonly DUKE_SUCELLUS: "duke_sucellus";
    readonly GENERAL_GRAARDOR: "general_graardor";
    readonly GIANT_MOLE: "giant_mole";
    readonly GROTESQUE_GUARDIANS: "grotesque_guardians";
    readonly HESPORI: "hespori";
    readonly KALPHITE_QUEEN: "kalphite_queen";
    readonly KING_BLACK_DRAGON: "king_black_dragon";
    readonly KRAKEN: "kraken";
    readonly KREEARRA: "kreearra";
    readonly KRIL_TSUTSAROTH: "kril_tsutsaroth";
    readonly LUNAR_CHESTS: "lunar_chests";
    readonly MIMIC: "mimic";
    readonly NEX: "nex";
    readonly NIGHTMARE: "nightmare";
    readonly PHOSANIS_NIGHTMARE: "phosanis_nightmare";
    readonly OBOR: "obor";
    readonly PHANTOM_MUSPAH: "phantom_muspah";
    readonly SARACHNIS: "sarachnis";
    readonly SCORPIA: "scorpia";
    readonly SCURRIUS: "scurrius";
    readonly SKOTIZO: "skotizo";
    readonly SOL_HEREDIT: "sol_heredit";
    readonly SPINDEL: "spindel";
    readonly TEMPOROSS: "tempoross";
    readonly THE_GAUNTLET: "the_gauntlet";
    readonly THE_CORRUPTED_GAUNTLET: "the_corrupted_gauntlet";
    readonly THE_HUEYCOATL: "the_hueycoatl";
    readonly THE_LEVIATHAN: "the_leviathan";
    readonly THE_ROYAL_TITANS: "the_royal_titans";
    readonly THE_WHISPERER: "the_whisperer";
    readonly THEATRE_OF_BLOOD: "theatre_of_blood";
    readonly THEATRE_OF_BLOOD_HARD_MODE: "theatre_of_blood_hard_mode";
    readonly THERMONUCLEAR_SMOKE_DEVIL: "thermonuclear_smoke_devil";
    readonly TOMBS_OF_AMASCUT: "tombs_of_amascut";
    readonly TOMBS_OF_AMASCUT_EXPERT: "tombs_of_amascut_expert";
    readonly TZKAL_ZUK: "tzkal_zuk";
    readonly TZTOK_JAD: "tztok_jad";
    readonly VARDORVIS: "vardorvis";
    readonly VENENATIS: "venenatis";
    readonly VETION: "vetion";
    readonly VORKATH: "vorkath";
    readonly WINTERTODT: "wintertodt";
    readonly YAMA: "yama";
    readonly ZALCANO: "zalcano";
    readonly ZULRAH: "zulrah";
};
type Boss = (typeof Boss)[keyof typeof Boss];
declare const ComputedMetric: {
    readonly EHP: "ehp";
    readonly EHB: "ehb";
};
type ComputedMetric = (typeof ComputedMetric)[keyof typeof ComputedMetric];
declare const Metric: {
    readonly EHP: "ehp";
    readonly EHB: "ehb";
    readonly ABYSSAL_SIRE: "abyssal_sire";
    readonly ALCHEMICAL_HYDRA: "alchemical_hydra";
    readonly AMOXLIATL: "amoxliatl";
    readonly ARAXXOR: "araxxor";
    readonly ARTIO: "artio";
    readonly BARROWS_CHESTS: "barrows_chests";
    readonly BRYOPHYTA: "bryophyta";
    readonly CALLISTO: "callisto";
    readonly CALVARION: "calvarion";
    readonly CERBERUS: "cerberus";
    readonly CHAMBERS_OF_XERIC: "chambers_of_xeric";
    readonly CHAMBERS_OF_XERIC_CM: "chambers_of_xeric_challenge_mode";
    readonly CHAOS_ELEMENTAL: "chaos_elemental";
    readonly CHAOS_FANATIC: "chaos_fanatic";
    readonly COMMANDER_ZILYANA: "commander_zilyana";
    readonly CORPOREAL_BEAST: "corporeal_beast";
    readonly CRAZY_ARCHAEOLOGIST: "crazy_archaeologist";
    readonly DAGANNOTH_PRIME: "dagannoth_prime";
    readonly DAGANNOTH_REX: "dagannoth_rex";
    readonly DAGANNOTH_SUPREME: "dagannoth_supreme";
    readonly DERANGED_ARCHAEOLOGIST: "deranged_archaeologist";
    readonly DOOM_OF_MOKHAIOTL: "doom_of_mokhaiotl";
    readonly DUKE_SUCELLUS: "duke_sucellus";
    readonly GENERAL_GRAARDOR: "general_graardor";
    readonly GIANT_MOLE: "giant_mole";
    readonly GROTESQUE_GUARDIANS: "grotesque_guardians";
    readonly HESPORI: "hespori";
    readonly KALPHITE_QUEEN: "kalphite_queen";
    readonly KING_BLACK_DRAGON: "king_black_dragon";
    readonly KRAKEN: "kraken";
    readonly KREEARRA: "kreearra";
    readonly KRIL_TSUTSAROTH: "kril_tsutsaroth";
    readonly LUNAR_CHESTS: "lunar_chests";
    readonly MIMIC: "mimic";
    readonly NEX: "nex";
    readonly NIGHTMARE: "nightmare";
    readonly PHOSANIS_NIGHTMARE: "phosanis_nightmare";
    readonly OBOR: "obor";
    readonly PHANTOM_MUSPAH: "phantom_muspah";
    readonly SARACHNIS: "sarachnis";
    readonly SCORPIA: "scorpia";
    readonly SCURRIUS: "scurrius";
    readonly SKOTIZO: "skotizo";
    readonly SOL_HEREDIT: "sol_heredit";
    readonly SPINDEL: "spindel";
    readonly TEMPOROSS: "tempoross";
    readonly THE_GAUNTLET: "the_gauntlet";
    readonly THE_CORRUPTED_GAUNTLET: "the_corrupted_gauntlet";
    readonly THE_HUEYCOATL: "the_hueycoatl";
    readonly THE_LEVIATHAN: "the_leviathan";
    readonly THE_ROYAL_TITANS: "the_royal_titans";
    readonly THE_WHISPERER: "the_whisperer";
    readonly THEATRE_OF_BLOOD: "theatre_of_blood";
    readonly THEATRE_OF_BLOOD_HARD_MODE: "theatre_of_blood_hard_mode";
    readonly THERMONUCLEAR_SMOKE_DEVIL: "thermonuclear_smoke_devil";
    readonly TOMBS_OF_AMASCUT: "tombs_of_amascut";
    readonly TOMBS_OF_AMASCUT_EXPERT: "tombs_of_amascut_expert";
    readonly TZKAL_ZUK: "tzkal_zuk";
    readonly TZTOK_JAD: "tztok_jad";
    readonly VARDORVIS: "vardorvis";
    readonly VENENATIS: "venenatis";
    readonly VETION: "vetion";
    readonly VORKATH: "vorkath";
    readonly WINTERTODT: "wintertodt";
    readonly YAMA: "yama";
    readonly ZALCANO: "zalcano";
    readonly ZULRAH: "zulrah";
    readonly LEAGUE_POINTS: "league_points";
    readonly BOUNTY_HUNTER_HUNTER: "bounty_hunter_hunter";
    readonly BOUNTY_HUNTER_ROGUE: "bounty_hunter_rogue";
    readonly CLUE_SCROLLS_ALL: "clue_scrolls_all";
    readonly CLUE_SCROLLS_BEGINNER: "clue_scrolls_beginner";
    readonly CLUE_SCROLLS_EASY: "clue_scrolls_easy";
    readonly CLUE_SCROLLS_MEDIUM: "clue_scrolls_medium";
    readonly CLUE_SCROLLS_HARD: "clue_scrolls_hard";
    readonly CLUE_SCROLLS_ELITE: "clue_scrolls_elite";
    readonly CLUE_SCROLLS_MASTER: "clue_scrolls_master";
    readonly LAST_MAN_STANDING: "last_man_standing";
    readonly PVP_ARENA: "pvp_arena";
    readonly SOUL_WARS_ZEAL: "soul_wars_zeal";
    readonly GUARDIANS_OF_THE_RIFT: "guardians_of_the_rift";
    readonly COLOSSEUM_GLORY: "colosseum_glory";
    readonly COLLECTIONS_LOGGED: "collections_logged";
    readonly OVERALL: "overall";
    readonly ATTACK: "attack";
    readonly DEFENCE: "defence";
    readonly STRENGTH: "strength";
    readonly HITPOINTS: "hitpoints";
    readonly RANGED: "ranged";
    readonly PRAYER: "prayer";
    readonly MAGIC: "magic";
    readonly COOKING: "cooking";
    readonly WOODCUTTING: "woodcutting";
    readonly FLETCHING: "fletching";
    readonly FISHING: "fishing";
    readonly FIREMAKING: "firemaking";
    readonly CRAFTING: "crafting";
    readonly SMITHING: "smithing";
    readonly MINING: "mining";
    readonly HERBLORE: "herblore";
    readonly AGILITY: "agility";
    readonly THIEVING: "thieving";
    readonly SLAYER: "slayer";
    readonly FARMING: "farming";
    readonly RUNECRAFTING: "runecrafting";
    readonly HUNTER: "hunter";
    readonly CONSTRUCTION: "construction";
};
type Metric = (typeof Metric)[keyof typeof Metric];
declare const METRICS: Metric[];
declare const SKILLS: Skill[];
declare const BOSSES: Boss[];
declare const ACTIVITIES: Activity[];
declare const COMPUTED_METRICS: ComputedMetric[];

interface Snapshot {
    id: number;
    playerId: number;
    importedAt: Date | null;
    createdAt: Date;
    overallRank: number;
    overallExperience: number;
    overallLevel: number;
    attackRank: number;
    attackExperience: number;
    defenceRank: number;
    defenceExperience: number;
    strengthRank: number;
    strengthExperience: number;
    hitpointsRank: number;
    hitpointsExperience: number;
    rangedRank: number;
    rangedExperience: number;
    prayerRank: number;
    prayerExperience: number;
    magicRank: number;
    magicExperience: number;
    cookingRank: number;
    cookingExperience: number;
    woodcuttingRank: number;
    woodcuttingExperience: number;
    fletchingRank: number;
    fletchingExperience: number;
    fishingRank: number;
    fishingExperience: number;
    firemakingRank: number;
    firemakingExperience: number;
    craftingRank: number;
    craftingExperience: number;
    smithingRank: number;
    smithingExperience: number;
    miningRank: number;
    miningExperience: number;
    herbloreRank: number;
    herbloreExperience: number;
    agilityRank: number;
    agilityExperience: number;
    thievingRank: number;
    thievingExperience: number;
    slayerRank: number;
    slayerExperience: number;
    farmingRank: number;
    farmingExperience: number;
    runecraftingRank: number;
    runecraftingExperience: number;
    hunterRank: number;
    hunterExperience: number;
    constructionRank: number;
    constructionExperience: number;
    league_pointsRank: number;
    league_pointsScore: number;
    bounty_hunter_hunterRank: number;
    bounty_hunter_hunterScore: number;
    bounty_hunter_rogueRank: number;
    bounty_hunter_rogueScore: number;
    clue_scrolls_allRank: number;
    clue_scrolls_allScore: number;
    clue_scrolls_beginnerRank: number;
    clue_scrolls_beginnerScore: number;
    clue_scrolls_easyRank: number;
    clue_scrolls_easyScore: number;
    clue_scrolls_mediumRank: number;
    clue_scrolls_mediumScore: number;
    clue_scrolls_hardRank: number;
    clue_scrolls_hardScore: number;
    clue_scrolls_eliteRank: number;
    clue_scrolls_eliteScore: number;
    clue_scrolls_masterRank: number;
    clue_scrolls_masterScore: number;
    last_man_standingRank: number;
    last_man_standingScore: number;
    pvp_arenaRank: number;
    pvp_arenaScore: number;
    soul_wars_zealRank: number;
    soul_wars_zealScore: number;
    guardians_of_the_riftRank: number;
    guardians_of_the_riftScore: number;
    colosseum_gloryRank: number;
    colosseum_gloryScore: number;
    collections_loggedRank: number;
    collections_loggedScore: number;
    abyssal_sireRank: number;
    abyssal_sireKills: number;
    alchemical_hydraRank: number;
    alchemical_hydraKills: number;
    amoxliatlRank: number;
    amoxliatlKills: number;
    araxxorRank: number;
    araxxorKills: number;
    artioRank: number;
    artioKills: number;
    barrows_chestsRank: number;
    barrows_chestsKills: number;
    bryophytaRank: number;
    bryophytaKills: number;
    cerberusRank: number;
    cerberusKills: number;
    callistoRank: number;
    callistoKills: number;
    calvarionRank: number;
    calvarionKills: number;
    chambers_of_xericRank: number;
    chambers_of_xericKills: number;
    chambers_of_xeric_challenge_modeRank: number;
    chambers_of_xeric_challenge_modeKills: number;
    chaos_elementalRank: number;
    chaos_elementalKills: number;
    chaos_fanaticRank: number;
    chaos_fanaticKills: number;
    commander_zilyanaRank: number;
    commander_zilyanaKills: number;
    corporeal_beastRank: number;
    corporeal_beastKills: number;
    crazy_archaeologistRank: number;
    crazy_archaeologistKills: number;
    dagannoth_primeRank: number;
    dagannoth_primeKills: number;
    dagannoth_rexRank: number;
    dagannoth_rexKills: number;
    dagannoth_supremeRank: number;
    dagannoth_supremeKills: number;
    deranged_archaeologistRank: number;
    deranged_archaeologistKills: number;
    doom_of_mokhaiotlRank: number;
    doom_of_mokhaiotlKills: number;
    duke_sucellusRank: number;
    duke_sucellusKills: number;
    general_graardorRank: number;
    general_graardorKills: number;
    giant_moleRank: number;
    giant_moleKills: number;
    grotesque_guardiansRank: number;
    grotesque_guardiansKills: number;
    hesporiRank: number;
    hesporiKills: number;
    kalphite_queenRank: number;
    kalphite_queenKills: number;
    king_black_dragonRank: number;
    king_black_dragonKills: number;
    krakenRank: number;
    krakenKills: number;
    kreearraRank: number;
    kreearraKills: number;
    kril_tsutsarothRank: number;
    kril_tsutsarothKills: number;
    lunar_chestsRank: number;
    lunar_chestsKills: number;
    mimicRank: number;
    mimicKills: number;
    nexRank: number;
    nexKills: number;
    nightmareRank: number;
    nightmareKills: number;
    phosanis_nightmareRank: number;
    phosanis_nightmareKills: number;
    oborRank: number;
    oborKills: number;
    phantom_muspahRank: number;
    phantom_muspahKills: number;
    sarachnisRank: number;
    sarachnisKills: number;
    scorpiaRank: number;
    scorpiaKills: number;
    scurriusRank: number;
    scurriusKills: number;
    skotizoRank: number;
    skotizoKills: number;
    sol_hereditRank: number;
    sol_hereditKills: number;
    spindelRank: number;
    spindelKills: number;
    temporossRank: number;
    temporossKills: number;
    the_gauntletRank: number;
    the_gauntletKills: number;
    the_corrupted_gauntletRank: number;
    the_corrupted_gauntletKills: number;
    the_hueycoatlRank: number;
    the_hueycoatlKills: number;
    the_leviathanRank: number;
    the_leviathanKills: number;
    the_royal_titansRank: number;
    the_royal_titansKills: number;
    the_whispererRank: number;
    the_whispererKills: number;
    theatre_of_bloodRank: number;
    theatre_of_bloodKills: number;
    theatre_of_blood_hard_modeRank: number;
    theatre_of_blood_hard_modeKills: number;
    thermonuclear_smoke_devilRank: number;
    thermonuclear_smoke_devilKills: number;
    tombs_of_amascutRank: number;
    tombs_of_amascutKills: number;
    tombs_of_amascut_expertRank: number;
    tombs_of_amascut_expertKills: number;
    tzkal_zukRank: number;
    tzkal_zukKills: number;
    tztok_jadRank: number;
    tztok_jadKills: number;
    vardorvisRank: number;
    vardorvisKills: number;
    venenatisRank: number;
    venenatisKills: number;
    vetionRank: number;
    vetionKills: number;
    vorkathRank: number;
    vorkathKills: number;
    wintertodtRank: number;
    wintertodtKills: number;
    yamaRank: number;
    yamaKills: number;
    zalcanoRank: number;
    zalcanoKills: number;
    zulrahRank: number;
    zulrahKills: number;
    ehpRank: number;
    ehpValue: number;
    ehbRank: number;
    ehbValue: number;
}

interface AchievementDefinition {
    name: string;
    metric: Metric;
    measure: string;
    threshold: number;
    validate: (snapshot: Snapshot) => boolean;
    getCurrentValue: (snapshot: Snapshot) => number;
}

declare enum MetricMeasure {
    EXPERIENCE = "experience",
    KILLS = "kills",
    SCORE = "score",
    VALUE = "value"
}

type AchievementMeasure = MetricMeasure | 'levels';

interface Achievement {
    playerId: number;
    name: string;
    metric: Metric;
    threshold: number;
    accuracy: number | null;
    createdAt: Date;
}

interface BossMetaConfig {
    boss: Boss;
    rate: number;
}

declare const Period: {
    readonly FIVE_MIN: "five_min";
    readonly DAY: "day";
    readonly WEEK: "week";
    readonly MONTH: "month";
    readonly YEAR: "year";
};
type Period = (typeof Period)[keyof typeof Period];
declare const PERIODS: ("five_min" | "day" | "week" | "month" | "year")[];

interface CachedDelta {
    playerId: number;
    period: Period;
    metric: Metric;
    value: number;
    startedAt: Date;
    endedAt: Date;
    updatedAt: Date;
}

declare enum CompetitionCSVTableType {
    TEAM = "team",
    TEAMS = "teams",
    PARTICIPANTS = "participants"
}

interface CompetitionMetric {
    competitionId: number;
    metric: Metric;
    createdAt: Date;
    deletedAt: Date | null;
}

declare enum CompetitionStatus {
    UPCOMING = "upcoming",
    ONGOING = "ongoing",
    FINISHED = "finished"
}
declare const COMPETITION_STATUSES: CompetitionStatus[];

interface CompetitionTeam {
    name: string;
    participants: string[];
}

declare const CompetitionType: {
    readonly CLASSIC: "classic";
    readonly TEAM: "team";
};
type CompetitionType = (typeof CompetitionType)[keyof typeof CompetitionType];
declare const COMPETITION_TYPES: CompetitionType[];

interface Competition {
    id: number;
    title: string;
    type: CompetitionType;
    startsAt: Date;
    endsAt: Date;
    groupId: number | null;
    score: number;
    visible: boolean;
    verificationHash: string;
    createdAt: Date | null;
    updatedAt: Date | null;
    creatorIpHash: string | null;
}

declare const Country: {
    readonly AD: "AD";
    readonly AE: "AE";
    readonly AF: "AF";
    readonly AG: "AG";
    readonly AI: "AI";
    readonly AL: "AL";
    readonly AM: "AM";
    readonly AO: "AO";
    readonly AQ: "AQ";
    readonly AR: "AR";
    readonly AS: "AS";
    readonly AT: "AT";
    readonly AU: "AU";
    readonly AW: "AW";
    readonly AX: "AX";
    readonly AZ: "AZ";
    readonly BA: "BA";
    readonly BB: "BB";
    readonly BD: "BD";
    readonly BE: "BE";
    readonly BF: "BF";
    readonly BG: "BG";
    readonly BH: "BH";
    readonly BI: "BI";
    readonly BJ: "BJ";
    readonly BL: "BL";
    readonly BM: "BM";
    readonly BN: "BN";
    readonly BO: "BO";
    readonly BQ: "BQ";
    readonly BR: "BR";
    readonly BS: "BS";
    readonly BT: "BT";
    readonly BV: "BV";
    readonly BW: "BW";
    readonly BY: "BY";
    readonly BZ: "BZ";
    readonly CA: "CA";
    readonly CC: "CC";
    readonly CD: "CD";
    readonly CF: "CF";
    readonly CG: "CG";
    readonly CH: "CH";
    readonly CI: "CI";
    readonly CK: "CK";
    readonly CL: "CL";
    readonly CM: "CM";
    readonly CN: "CN";
    readonly CO: "CO";
    readonly CR: "CR";
    readonly CU: "CU";
    readonly CV: "CV";
    readonly CW: "CW";
    readonly CX: "CX";
    readonly CY: "CY";
    readonly CZ: "CZ";
    readonly DE: "DE";
    readonly DJ: "DJ";
    readonly DK: "DK";
    readonly DM: "DM";
    readonly DO: "DO";
    readonly DZ: "DZ";
    readonly EC: "EC";
    readonly EE: "EE";
    readonly EG: "EG";
    readonly EH: "EH";
    readonly ER: "ER";
    readonly ES: "ES";
    readonly ET: "ET";
    readonly FI: "FI";
    readonly FJ: "FJ";
    readonly FK: "FK";
    readonly FM: "FM";
    readonly FO: "FO";
    readonly FR: "FR";
    readonly GA: "GA";
    readonly GB: "GB";
    readonly GB_NIR: "GB_NIR";
    readonly GB_SCT: "GB_SCT";
    readonly GB_WLS: "GB_WLS";
    readonly GD: "GD";
    readonly GE: "GE";
    readonly GF: "GF";
    readonly GG: "GG";
    readonly GH: "GH";
    readonly GI: "GI";
    readonly GL: "GL";
    readonly GM: "GM";
    readonly GN: "GN";
    readonly GP: "GP";
    readonly GQ: "GQ";
    readonly GR: "GR";
    readonly GS: "GS";
    readonly GT: "GT";
    readonly GU: "GU";
    readonly GW: "GW";
    readonly GY: "GY";
    readonly HK: "HK";
    readonly HM: "HM";
    readonly HN: "HN";
    readonly HR: "HR";
    readonly HT: "HT";
    readonly HU: "HU";
    readonly ID: "ID";
    readonly IE: "IE";
    readonly IL: "IL";
    readonly IM: "IM";
    readonly IN: "IN";
    readonly IO: "IO";
    readonly IQ: "IQ";
    readonly IR: "IR";
    readonly IS: "IS";
    readonly IT: "IT";
    readonly JE: "JE";
    readonly JM: "JM";
    readonly JO: "JO";
    readonly JP: "JP";
    readonly KE: "KE";
    readonly KG: "KG";
    readonly KH: "KH";
    readonly KI: "KI";
    readonly KM: "KM";
    readonly KN: "KN";
    readonly KP: "KP";
    readonly KR: "KR";
    readonly KW: "KW";
    readonly KY: "KY";
    readonly KZ: "KZ";
    readonly LA: "LA";
    readonly LB: "LB";
    readonly LC: "LC";
    readonly LI: "LI";
    readonly LK: "LK";
    readonly LR: "LR";
    readonly LS: "LS";
    readonly LT: "LT";
    readonly LU: "LU";
    readonly LV: "LV";
    readonly LY: "LY";
    readonly MA: "MA";
    readonly MC: "MC";
    readonly MD: "MD";
    readonly ME: "ME";
    readonly MF: "MF";
    readonly MG: "MG";
    readonly MH: "MH";
    readonly MK: "MK";
    readonly ML: "ML";
    readonly MM: "MM";
    readonly MN: "MN";
    readonly MO: "MO";
    readonly MP: "MP";
    readonly MQ: "MQ";
    readonly MR: "MR";
    readonly MS: "MS";
    readonly MT: "MT";
    readonly MU: "MU";
    readonly MV: "MV";
    readonly MW: "MW";
    readonly MX: "MX";
    readonly MY: "MY";
    readonly MZ: "MZ";
    readonly NA: "NA";
    readonly NC: "NC";
    readonly NE: "NE";
    readonly NF: "NF";
    readonly NG: "NG";
    readonly NI: "NI";
    readonly NL: "NL";
    readonly NO: "NO";
    readonly NP: "NP";
    readonly NR: "NR";
    readonly NU: "NU";
    readonly NZ: "NZ";
    readonly OM: "OM";
    readonly PA: "PA";
    readonly PE: "PE";
    readonly PF: "PF";
    readonly PG: "PG";
    readonly PH: "PH";
    readonly PK: "PK";
    readonly PL: "PL";
    readonly PM: "PM";
    readonly PN: "PN";
    readonly PR: "PR";
    readonly PS: "PS";
    readonly PT: "PT";
    readonly PW: "PW";
    readonly PY: "PY";
    readonly QA: "QA";
    readonly RE: "RE";
    readonly RO: "RO";
    readonly RS: "RS";
    readonly RU: "RU";
    readonly RW: "RW";
    readonly SA: "SA";
    readonly SB: "SB";
    readonly SC: "SC";
    readonly SD: "SD";
    readonly SE: "SE";
    readonly SG: "SG";
    readonly SH: "SH";
    readonly SI: "SI";
    readonly SJ: "SJ";
    readonly SK: "SK";
    readonly SL: "SL";
    readonly SM: "SM";
    readonly SN: "SN";
    readonly SO: "SO";
    readonly SR: "SR";
    readonly SS: "SS";
    readonly ST: "ST";
    readonly SV: "SV";
    readonly SX: "SX";
    readonly SY: "SY";
    readonly SZ: "SZ";
    readonly TC: "TC";
    readonly TD: "TD";
    readonly TF: "TF";
    readonly TG: "TG";
    readonly TH: "TH";
    readonly TJ: "TJ";
    readonly TK: "TK";
    readonly TL: "TL";
    readonly TM: "TM";
    readonly TN: "TN";
    readonly TO: "TO";
    readonly TR: "TR";
    readonly TT: "TT";
    readonly TV: "TV";
    readonly TW: "TW";
    readonly TZ: "TZ";
    readonly UA: "UA";
    readonly UG: "UG";
    readonly UM: "UM";
    readonly US: "US";
    readonly UY: "UY";
    readonly UZ: "UZ";
    readonly VA: "VA";
    readonly VC: "VC";
    readonly VE: "VE";
    readonly VG: "VG";
    readonly VI: "VI";
    readonly VN: "VN";
    readonly VU: "VU";
    readonly WF: "WF";
    readonly WS: "WS";
    readonly YE: "YE";
    readonly YT: "YT";
    readonly ZA: "ZA";
    readonly ZM: "ZM";
    readonly ZW: "ZW";
};
type Country = (typeof Country)[keyof typeof Country];
declare const COUNTRY_CODES: Country[];

interface Delta {
    playerId: number;
    period: Period;
    startedAt: Date;
    endedAt: Date;
    updatedAt: Date | null;
    overall: number;
    attack: number;
    defence: number;
    strength: number;
    hitpoints: number;
    ranged: number;
    prayer: number;
    magic: number;
    cooking: number;
    woodcutting: number;
    fletching: number;
    fishing: number;
    firemaking: number;
    crafting: number;
    smithing: number;
    mining: number;
    herblore: number;
    agility: number;
    thieving: number;
    slayer: number;
    farming: number;
    runecrafting: number;
    hunter: number;
    construction: number;
    abyssal_sire: number;
    alchemical_hydra: number;
    amoxliatl: number;
    araxxor: number;
    artio: number;
    barrows_chests: number;
    bryophyta: number;
    callisto: number;
    calvarion: number;
    cerberus: number;
    chambers_of_xeric: number;
    chambers_of_xeric_challenge_mode: number;
    chaos_elemental: number;
    chaos_fanatic: number;
    commander_zilyana: number;
    corporeal_beast: number;
    crazy_archaeologist: number;
    dagannoth_prime: number;
    dagannoth_rex: number;
    dagannoth_supreme: number;
    deranged_archaeologist: number;
    doom_of_mokhaiotl: number;
    duke_sucellus: number;
    general_graardor: number;
    giant_mole: number;
    grotesque_guardians: number;
    hespori: number;
    kalphite_queen: number;
    king_black_dragon: number;
    kraken: number;
    kreearra: number;
    kril_tsutsaroth: number;
    lunar_chests: number;
    mimic: number;
    nex: number;
    nightmare: number;
    phosanis_nightmare: number;
    obor: number;
    phantom_muspah: number;
    sarachnis: number;
    scorpia: number;
    scurrius: number;
    skotizo: number;
    sol_heredit: number;
    spindel: number;
    tempoross: number;
    the_gauntlet: number;
    the_corrupted_gauntlet: number;
    the_hueycoatl: number;
    the_leviathan: number;
    the_royal_titans: number;
    the_whisperer: number;
    theatre_of_blood: number;
    theatre_of_blood_hard_mode: number;
    thermonuclear_smoke_devil: number;
    tombs_of_amascut: number;
    tombs_of_amascut_expert: number;
    tzkal_zuk: number;
    tztok_jad: number;
    vardorvis: number;
    venenatis: number;
    vetion: number;
    vorkath: number;
    wintertodt: number;
    yama: number;
    zalcano: number;
    zulrah: number;
    league_points: number;
    bounty_hunter_hunter: number;
    bounty_hunter_rogue: number;
    clue_scrolls_all: number;
    clue_scrolls_beginner: number;
    clue_scrolls_easy: number;
    clue_scrolls_medium: number;
    clue_scrolls_hard: number;
    clue_scrolls_elite: number;
    clue_scrolls_master: number;
    last_man_standing: number;
    pvp_arena: number;
    soul_wars_zeal: number;
    guardians_of_the_rift: number;
    colosseum_glory: number;
    collections_logged: number;
    ehp: number;
    ehb: number;
}

declare enum EfficiencyAlgorithmType {
    MAIN = "main",
    IRONMAN = "ironman",
    ULTIMATE = "ultimate",
    LVL3 = "lvl3",
    F2P = "f2p",
    F2P_LVL3 = "f2p_lvl3",
    F2P_IRONMAN = "f2p_ironman",
    F2P_LVL3_IRONMAN = "f2p_lvl3_ironman",
    DEF1 = "def1"
}

declare const GroupRole: {
    readonly ACHIEVER: "achiever";
    readonly ADAMANT: "adamant";
    readonly ADEPT: "adept";
    readonly ADMINISTRATOR: "administrator";
    readonly ADMIRAL: "admiral";
    readonly ADVENTURER: "adventurer";
    readonly AIR: "air";
    readonly ANCHOR: "anchor";
    readonly APOTHECARY: "apothecary";
    readonly ARCHER: "archer";
    readonly ARMADYLEAN: "armadylean";
    readonly ARTILLERY: "artillery";
    readonly ARTISAN: "artisan";
    readonly ASGARNIAN: "asgarnian";
    readonly ASSASSIN: "assassin";
    readonly ASSISTANT: "assistant";
    readonly ASTRAL: "astral";
    readonly ATHLETE: "athlete";
    readonly ATTACKER: "attacker";
    readonly BANDIT: "bandit";
    readonly BANDOSIAN: "bandosian";
    readonly BARBARIAN: "barbarian";
    readonly BATTLEMAGE: "battlemage";
    readonly BEAST: "beast";
    readonly BERSERKER: "berserker";
    readonly BLISTERWOOD: "blisterwood";
    readonly BLOOD: "blood";
    readonly BLUE: "blue";
    readonly BOB: "bob";
    readonly BODY: "body";
    readonly BRASSICAN: "brassican";
    readonly BRAWLER: "brawler";
    readonly BRIGADIER: "brigadier";
    readonly BRIGAND: "brigand";
    readonly BRONZE: "bronze";
    readonly BRUISER: "bruiser";
    readonly BULWARK: "bulwark";
    readonly BURGLAR: "burglar";
    readonly BURNT: "burnt";
    readonly CADET: "cadet";
    readonly CAPTAIN: "captain";
    readonly CARRY: "carry";
    readonly CHAMPION: "champion";
    readonly CHAOS: "chaos";
    readonly CLERIC: "cleric";
    readonly COLLECTOR: "collector";
    readonly COLONEL: "colonel";
    readonly COMMANDER: "commander";
    readonly COMPETITOR: "competitor";
    readonly COMPLETIONIST: "completionist";
    readonly CONSTRUCTOR: "constructor";
    readonly COOK: "cook";
    readonly COORDINATOR: "coordinator";
    readonly CORPORAL: "corporal";
    readonly COSMIC: "cosmic";
    readonly COUNCILLOR: "councillor";
    readonly CRAFTER: "crafter";
    readonly CREW: "crew";
    readonly CRUSADER: "crusader";
    readonly CUTPURSE: "cutpurse";
    readonly DEATH: "death";
    readonly DEFENDER: "defender";
    readonly DEFILER: "defiler";
    readonly DEPUTY_OWNER: "deputy_owner";
    readonly DESTROYER: "destroyer";
    readonly DIAMOND: "diamond";
    readonly DISEASED: "diseased";
    readonly DOCTOR: "doctor";
    readonly DOGSBODY: "dogsbody";
    readonly DRAGON: "dragon";
    readonly DRAGONSTONE: "dragonstone";
    readonly DRUID: "druid";
    readonly DUELLIST: "duellist";
    readonly EARTH: "earth";
    readonly ELITE: "elite";
    readonly EMERALD: "emerald";
    readonly ENFORCER: "enforcer";
    readonly EPIC: "epic";
    readonly EXECUTIVE: "executive";
    readonly EXPERT: "expert";
    readonly EXPLORER: "explorer";
    readonly FARMER: "farmer";
    readonly FEEDER: "feeder";
    readonly FIGHTER: "fighter";
    readonly FIRE: "fire";
    readonly FIREMAKER: "firemaker";
    readonly FIRESTARTER: "firestarter";
    readonly FISHER: "fisher";
    readonly FLETCHER: "fletcher";
    readonly FORAGER: "forager";
    readonly FREMENNIK: "fremennik";
    readonly GAMER: "gamer";
    readonly GATHERER: "gatherer";
    readonly GENERAL: "general";
    readonly GNOME_CHILD: "gnome_child";
    readonly GNOME_ELDER: "gnome_elder";
    readonly GOBLIN: "goblin";
    readonly GOLD: "gold";
    readonly GOON: "goon";
    readonly GREEN: "green";
    readonly GREY: "grey";
    readonly GUARDIAN: "guardian";
    readonly GUTHIXIAN: "guthixian";
    readonly HARPOON: "harpoon";
    readonly HEALER: "healer";
    readonly HELLCAT: "hellcat";
    readonly HELPER: "helper";
    readonly HERBOLOGIST: "herbologist";
    readonly HERO: "hero";
    readonly HOLY: "holy";
    readonly HOARDER: "hoarder";
    readonly HUNTER: "hunter";
    readonly IGNITOR: "ignitor";
    readonly ILLUSIONIST: "illusionist";
    readonly IMP: "imp";
    readonly INFANTRY: "infantry";
    readonly INQUISITOR: "inquisitor";
    readonly IRON: "iron";
    readonly JADE: "jade";
    readonly JUSTICIAR: "justiciar";
    readonly KANDARIN: "kandarin";
    readonly KARAMJAN: "karamjan";
    readonly KHARIDIAN: "kharidian";
    readonly KITTEN: "kitten";
    readonly KNIGHT: "knight";
    readonly LABOURER: "labourer";
    readonly LAW: "law";
    readonly LEADER: "leader";
    readonly LEARNER: "learner";
    readonly LEGACY: "legacy";
    readonly LEGEND: "legend";
    readonly LEGIONNAIRE: "legionnaire";
    readonly LIEUTENANT: "lieutenant";
    readonly LOOTER: "looter";
    readonly LUMBERJACK: "lumberjack";
    readonly MAGIC: "magic";
    readonly MAGICIAN: "magician";
    readonly MAJOR: "major";
    readonly MAPLE: "maple";
    readonly MARSHAL: "marshal";
    readonly MASTER: "master";
    readonly MAXED: "maxed";
    readonly MEDIATOR: "mediator";
    readonly MEDIC: "medic";
    readonly MENTOR: "mentor";
    readonly MEMBER: "member";
    readonly MERCHANT: "merchant";
    readonly MIND: "mind";
    readonly MINER: "miner";
    readonly MINION: "minion";
    readonly MISTHALINIAN: "misthalinian";
    readonly MITHRIL: "mithril";
    readonly MODERATOR: "moderator";
    readonly MONARCH: "monarch";
    readonly MORYTANIAN: "morytanian";
    readonly MYSTIC: "mystic";
    readonly MYTH: "myth";
    readonly NATURAL: "natural";
    readonly NATURE: "nature";
    readonly NECROMANCER: "necromancer";
    readonly NINJA: "ninja";
    readonly NOBLE: "noble";
    readonly NOVICE: "novice";
    readonly NURSE: "nurse";
    readonly OAK: "oak";
    readonly OFFICER: "officer";
    readonly ONYX: "onyx";
    readonly OPAL: "opal";
    readonly ORACLE: "oracle";
    readonly ORANGE: "orange";
    readonly OWNER: "owner";
    readonly PAGE: "page";
    readonly PALADIN: "paladin";
    readonly PAWN: "pawn";
    readonly PILGRIM: "pilgrim";
    readonly PINE: "pine";
    readonly PINK: "pink";
    readonly PREFECT: "prefect";
    readonly PRIEST: "priest";
    readonly PRIVATE: "private";
    readonly PRODIGY: "prodigy";
    readonly PROSELYTE: "proselyte";
    readonly PROSPECTOR: "prospector";
    readonly PROTECTOR: "protector";
    readonly PURE: "pure";
    readonly PURPLE: "purple";
    readonly PYROMANCER: "pyromancer";
    readonly QUESTER: "quester";
    readonly RACER: "racer";
    readonly RAIDER: "raider";
    readonly RANGER: "ranger";
    readonly RECORD_CHASER: "record_chaser";
    readonly RECRUIT: "recruit";
    readonly RECRUITER: "recruiter";
    readonly RED_TOPAZ: "red_topaz";
    readonly RED: "red";
    readonly ROGUE: "rogue";
    readonly RUBY: "ruby";
    readonly RUNE: "rune";
    readonly RUNECRAFTER: "runecrafter";
    readonly SAGE: "sage";
    readonly SAPPHIRE: "sapphire";
    readonly SARADOMINIST: "saradominist";
    readonly SAVIOUR: "saviour";
    readonly SCAVENGER: "scavenger";
    readonly SCHOLAR: "scholar";
    readonly SCOURGE: "scourge";
    readonly SCOUT: "scout";
    readonly SCRIBE: "scribe";
    readonly SEER: "seer";
    readonly SENATOR: "senator";
    readonly SENTRY: "sentry";
    readonly SERENIST: "serenist";
    readonly SERGEANT: "sergeant";
    readonly SHAMAN: "shaman";
    readonly SHERIFF: "sheriff";
    readonly SHORT_GREEN_GUY: "short_green_guy";
    readonly SKILLER: "skiller";
    readonly SKULLED: "skulled";
    readonly SLAYER: "slayer";
    readonly SMITER: "smiter";
    readonly SMITH: "smith";
    readonly SMUGGLER: "smuggler";
    readonly SNIPER: "sniper";
    readonly SOUL: "soul";
    readonly SPECIALIST: "specialist";
    readonly SPEED_RUNNER: "speed_runner";
    readonly SPELLCASTER: "spellcaster";
    readonly SQUIRE: "squire";
    readonly STAFF: "staff";
    readonly STEEL: "steel";
    readonly STRIDER: "strider";
    readonly STRIKER: "striker";
    readonly SUMMONER: "summoner";
    readonly SUPERIOR: "superior";
    readonly SUPERVISOR: "supervisor";
    readonly TEACHER: "teacher";
    readonly TEMPLAR: "templar";
    readonly THERAPIST: "therapist";
    readonly THIEF: "thief";
    readonly TIRANNIAN: "tirannian";
    readonly TRIALIST: "trialist";
    readonly TRICKSTER: "trickster";
    readonly TZKAL: "tzkal";
    readonly TZTOK: "tztok";
    readonly UNHOLY: "unholy";
    readonly VAGRANT: "vagrant";
    readonly VANGUARD: "vanguard";
    readonly WALKER: "walker";
    readonly WANDERER: "wanderer";
    readonly WARDEN: "warden";
    readonly WARLOCK: "warlock";
    readonly WARRIOR: "warrior";
    readonly WATER: "water";
    readonly WILD: "wild";
    readonly WILLOW: "willow";
    readonly WILY: "wily";
    readonly WINTUMBER: "wintumber";
    readonly WITCH: "witch";
    readonly WIZARD: "wizard";
    readonly WORKER: "worker";
    readonly WRATH: "wrath";
    readonly XERICIAN: "xerician";
    readonly YELLOW: "yellow";
    readonly YEW: "yew";
    readonly ZAMORAKIAN: "zamorakian";
    readonly ZAROSIAN: "zarosian";
    readonly ZEALOT: "zealot";
    readonly ZENYTE: "zenyte";
};
type GroupRole = (typeof GroupRole)[keyof typeof GroupRole];
declare const GROUP_ROLES: GroupRole[];

interface GroupRoleOrder {
    groupId: number;
    role: GroupRole;
    index: number;
}

interface GroupSocialLinks {
    id: number;
    groupId: number;
    website: string | null;
    discord: string | null;
    twitter: string | null;
    youtube: string | null;
    twitch: string | null;
    createdAt: Date;
    updatedAt: Date;
}

interface Group {
    id: number;
    name: string;
    clanChat: string | null;
    description: string | null;
    homeworld: number | null;
    verified: boolean;
    patron: boolean;
    visible: boolean;
    profileImage: string | null;
    bannerImage: string | null;
    score: number;
    verificationHash: string;
    createdAt: Date;
    updatedAt: Date;
    creatorIpHash: string | null;
}

declare const MemberActivityType: {
    readonly JOINED: "joined";
    readonly LEFT: "left";
    readonly CHANGED_ROLE: "changed_role";
};
type MemberActivityType = (typeof MemberActivityType)[keyof typeof MemberActivityType];

interface MemberActivity {
    groupId: number;
    playerId: number;
    type: MemberActivityType;
    role: GroupRole | null;
    previousRole: GroupRole | null;
    createdAt: Date;
}

interface Membership {
    playerId: number;
    groupId: number;
    role: GroupRole;
    createdAt: Date;
    updatedAt: Date;
}

interface MetricDelta {
    start: number;
    end: number;
    gained: number;
}

declare enum MetricType {
    SKILL = "skill",
    BOSS = "boss",
    ACTIVITY = "activity",
    COMPUTED = "computed"
}

type NameChangeDenyContext = {
    reason: 'manual_review';
} | {
    reason: 'old_stats_cannot_be_found';
} | {
    reason: 'new_name_not_on_the_hiscores';
} | {
    reason: 'negative_gains';
    negativeGains: Record<Metric, number>;
};
type NameChangeSkipContext = {
    reason: 'transition_period_too_long';
    maxHoursDiff: number;
    hoursDiff: number;
} | {
    reason: 'excessive_gains';
    ehpDiff: number;
    ehbDiff: number;
    hoursDiff: number;
} | {
    reason: 'total_level_too_low';
    minTotalLevel: number;
    totalLevel: number;
};
type NameChangeReviewContext = NameChangeSkipContext | NameChangeDenyContext;

declare const NameChangeStatus: {
    readonly PENDING: "pending";
    readonly DENIED: "denied";
    readonly APPROVED: "approved";
};
type NameChangeStatus = (typeof NameChangeStatus)[keyof typeof NameChangeStatus];

interface NameChange {
    id: number;
    playerId: number;
    oldName: string;
    newName: string;
    status: NameChangeStatus;
    reviewContext: NameChangeReviewContext | null;
    resolvedAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
}

interface Participation {
    playerId: number;
    competitionId: number;
    startSnapshotId: number | null;
    endSnapshotId: number | null;
    teamName: string | null;
    createdAt: Date;
    updatedAt: Date;
}

interface Patron {
    id: string;
    name: string;
    email: string;
    discordId: string | null;
    groupId: number | null;
    playerId: number | null;
    tier: number;
    createdAt: Date;
}

declare const PlayerAnnotationType: {
    readonly OPT_OUT: "opt_out";
    readonly OPT_OUT_GROUPS: "opt_out_groups";
    readonly OPT_OUT_COMPETITIONS: "opt_out_competitions";
    readonly BLOCKED: "blocked";
    readonly FAKE_F2P: "fake_f2p";
};
type PlayerAnnotationType = (typeof PlayerAnnotationType)[keyof typeof PlayerAnnotationType];

interface PlayerAnnotation {
    playerId: number;
    type: PlayerAnnotationType;
    createdAt: Date;
}

interface PlayerArchive {
    playerId: number;
    previousUsername: string;
    archiveUsername: string;
    restoredUsername: string | null;
    createdAt: Date;
    restoredAt: Date | null;
}

declare const PlayerBuild: {
    readonly MAIN: "main";
    readonly F2P: "f2p";
    readonly F2P_LVL3: "f2p_lvl3";
    readonly LVL3: "lvl3";
    readonly ZERKER: "zerker";
    readonly DEF1: "def1";
    readonly HP10: "hp10";
};
type PlayerBuild = (typeof PlayerBuild)[keyof typeof PlayerBuild];
declare const PLAYER_BUILDS: PlayerBuild[];

declare const PlayerStatus: {
    readonly ACTIVE: "active";
    readonly UNRANKED: "unranked";
    readonly FLAGGED: "flagged";
    readonly ARCHIVED: "archived";
    readonly BANNED: "banned";
};
type PlayerStatus = (typeof PlayerStatus)[keyof typeof PlayerStatus];
declare const PLAYER_STATUSES: PlayerStatus[];

declare const PlayerType: {
    readonly UNKNOWN: "unknown";
    readonly REGULAR: "regular";
    readonly IRONMAN: "ironman";
    readonly HARDCORE: "hardcore";
    readonly ULTIMATE: "ultimate";
};
type PlayerType = (typeof PlayerType)[keyof typeof PlayerType];
declare const PLAYER_TYPES: PlayerType[];

interface Player {
    id: number;
    username: string;
    displayName: string;
    type: PlayerType;
    build: PlayerBuild;
    status: PlayerStatus;
    country: Country | null;
    patron: boolean;
    exp: number;
    ehp: number;
    ehb: number;
    ttm: number;
    tt200m: number;
    registeredAt: Date;
    updatedAt: Date | null;
    lastChangedAt: Date | null;
    lastImportedAt: Date | null;
    latestSnapshotId: number | null;
}

interface Record$1 {
    playerId: number;
    period: Period;
    metric: Metric;
    value: number;
    updatedAt: Date;
}

interface SkillMetaBonus {
    originSkill: Skill;
    bonusSkill: Skill;
    startExp: number;
    endExp: number;
    maxBonus?: number;
    end: boolean;
    ratio: number;
}

interface SkillMetaMethod {
    rate: number;
    realRate?: number;
    startExp: number;
    description: string;
}

interface SkillMetaConfig {
    skill: Skill;
    methods: Array<SkillMetaMethod>;
    bonuses: SkillMetaBonus[];
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface AchievementResponse extends Achievement {
    measure: AchievementMeasure;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface AchievementProgressResponse extends Omit<AchievementResponse, 'createdAt'> {
    createdAt: Date | null;
    currentValue: number;
    absoluteProgress: number;
    relativeProgress: number;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface GroupResponse extends Omit<Group, 'verificationHash' | 'creatorIpHash'> {
    memberCount: number;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface CompetitionResponse extends Omit<Competition, 'verificationHash' | 'creatorIpHash'> {
    metric: Metric;
    metrics: Metric[];
    participantCount: number;
    group?: GroupResponse;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type ParticipationResponse = Omit<Participation, 'startSnapshotId' | 'endSnapshotId'>;

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type PlayerResponse = Omit<Player, 'latestSnapshotId'>;

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface CompetitionDetailsResponse extends CompetitionResponse {
    participations: Array<ParticipationResponse & {
        player: PlayerResponse;
        progress: MetricDelta;
        levels: MetricDelta;
    }>;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface SkillData {
    metric: Skill;
    rank: number;
    level: number;
    experience: number;
    ehp: number;
}
interface BossData {
    metric: Boss;
    rank: number;
    kills: number;
    ehb: number;
}
interface ActivityData {
    metric: Activity;
    rank: number;
    score: number;
}
interface ComputeMetricData {
    metric: ComputedMetric;
    rank: number;
    value: number;
}
interface SnapshotResponse {
    id: number;
    playerId: number;
    createdAt: Date;
    importedAt: Date | null;
    data: {
        skills: Record<Skill, SkillData>;
        bosses: Record<Boss, BossData>;
        activities: Record<Activity, ActivityData>;
        computed: Record<ComputedMetric, ComputeMetricData>;
    };
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type GroupRoleOrderResponse = GroupRoleOrder;

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type GroupSocialLinksResponse = Pick<GroupSocialLinks, 'website' | 'discord' | 'twitter' | 'youtube' | 'twitch'>;

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type MembershipResponse = Membership;

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface GroupDetailsResponse extends GroupResponse {
    socialLinks: GroupSocialLinksResponse;
    roleOrders: Array<GroupRoleOrderResponse>;
    memberships: Array<MembershipResponse & {
        player: PlayerResponse;
    }>;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */
interface GroupHiscoresEntryResponse {
    player: PlayerResponse;
    data: GroupHiscoresSkillData | GroupHiscoresBossData | GroupHiscoresActivityData | GroupHiscoresComputedMetricData;
}
interface GroupHiscoresSkillData {
    type: 'skill';
    rank: number;
    level: number;
    experience: number;
}
interface GroupHiscoresBossData {
    type: 'boss';
    rank: number;
    kills: number;
}
interface GroupHiscoresActivityData {
    type: 'activity';
    rank: number;
    score: number;
}
interface GroupHiscoresComputedMetricData {
    type: 'computed';
    rank: number;
    value: number;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface GroupMetricLeadersResponse {
    skills: Record<Skill, {
        player: PlayerResponse | null;
        metric: Skill;
        rank: number;
        level: number;
        experience: number;
    }>;
    bosses: Record<Boss, {
        player: PlayerResponse | null;
        metric: Boss;
        rank: number;
        kills: number;
    }>;
    activities: Record<Activity, {
        player: PlayerResponse | null;
        metric: Activity;
        rank: number;
        score: number;
    }>;
    computed: Record<ComputedMetric, {
        player: PlayerResponse | null;
        metric: ComputedMetric;
        rank: number;
        value: number;
    }>;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface GroupStatisticsResponse {
    maxedCombatCount: number;
    maxedTotalCount: number;
    maxed200msCount: number;
    averageStats: SnapshotResponse;
    metricLeaders: GroupMetricLeadersResponse;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type MemberActivityResponse = MemberActivity;

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type NameChangeResponse = NameChange;

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface NameChangeDetailsResponse {
    nameChange: NameChangeResponse;
    data?: {
        isNewOnHiscores: boolean;
        isOldOnHiscores: boolean;
        isNewTracked: boolean;
        hasNegativeGains: boolean;
        negativeGains: Record<Metric, number> | null;
        timeDiff: number;
        hoursDiff: number;
        ehpDiff: number;
        ehbDiff: number;
        oldStats: SnapshotResponse;
        newStats: SnapshotResponse | null;
    };
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface ParticipantHistoryResponse {
    player: PlayerResponse;
    history: Array<{
        value: number;
        date: Date;
    }>;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type PlayerAnnotationResponse = PlayerAnnotation;

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type PlayerArchiveResponse = PlayerArchive;

type PlayerCompetitionStandingResponse = ParticipationResponse & {
    competition: CompetitionResponse;
    progress: MetricDelta;
    levels: MetricDelta;
    rank: number;
};

interface PlayerDeltasMapResponse {
    skills: Record<Skill, {
        metric: Skill;
        ehp: MetricDelta;
        rank: MetricDelta;
        level: MetricDelta;
        experience: MetricDelta;
    }>;
    bosses: Record<Boss, {
        metric: Boss;
        ehb: MetricDelta;
        rank: MetricDelta;
        kills: MetricDelta;
    }>;
    activities: Record<Activity, {
        metric: Activity;
        rank: MetricDelta;
        score: MetricDelta;
    }>;
    computed: Record<ComputedMetric, {
        metric: ComputedMetric;
        rank: MetricDelta;
        value: MetricDelta;
    }>;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

interface PlayerDetailsResponse extends PlayerResponse {
    combatLevel: number;
    archive: PlayerArchiveResponse | null;
    annotations: Array<PlayerAnnotationResponse> | null;
    latestSnapshot: SnapshotResponse | null;
}

/**
 * Response types are used to format the data returned by the API.
 *
 * Although sometimes very similar to our database models,
 * they often include transformations, additional properties or sensitive field omissions.
 */

type RecordResponse = Record$1;

interface GenericCountMessageResponse {
    count: number;
    message: string;
}
interface GenericMessageResponse {
    message: string;
}
type TimeRangeFilter = {
    period: Period | string;
} | {
    startDate: Date;
    endDate: Date;
};
interface CreateGroupPayload {
    name: string;
    clanChat?: string;
    homeworld?: number;
    description?: string;
    members: Array<{
        username: string;
        role?: GroupRole;
    }>;
}
type EditGroupPayload = Partial<CreateGroupPayload> & {
    bannerImage?: string;
    profileImage?: string;
    socialLinks?: Partial<{
        website?: string | null;
        discord?: string | null;
        twitter?: string | null;
        twitch?: string | null;
        youtube?: string | null;
    }>;
    roleOrders?: Array<{
        role: GroupRole;
        index: number;
    }>;
};
type CreateCompetitionPayload = {
    title: string;
    metric: Metric;
    startsAt: Date;
    endsAt: Date;
    groupId?: number;
    groupVerificationCode?: string;
} & ({
    participants: string[];
} | {
    teams: CompetitionTeam[];
});
type EditCompetitionPayload = {
    title?: string;
    metric?: Metric;
    startsAt?: Date;
    endsAt?: Date;
    participants?: string[];
    teams?: CompetitionTeam[];
};

interface PaginationOptions {
    limit?: number;
    offset?: number;
}

declare class CompetitionsClient extends BaseAPIClient {
    /**
     * Searches for competitions that match a title, type, metric and status filter.
     * @returns A list of competitions.
     */
    searchCompetitions(filter: {
        title?: string;
        metric?: Metric;
        type?: CompetitionType;
        status?: CompetitionStatus;
    }, pagination?: PaginationOptions): Promise<CompetitionResponse[]>;
    /**
     * Fetches the competition's full details, including all the participants and their progress.
     * @returns A competition with a list of participants.
     */
    getCompetitionDetails(id: number, previewMetric?: Metric): Promise<CompetitionDetailsResponse>;
    /**
     * Fetches the competition's participant list in CSV format.
     * @returns A string containing the CSV content.
     */
    getCompetitionDetailsCSV(id: number, params?: {
        previewMetric?: Metric;
        teamName?: string;
        table?: CompetitionCSVTableType;
    }): Promise<string>;
    /**
     * Fetches all the values (exp, kc, etc) in chronological order within the bounds
     * of the competition, for the top 5 participants.
     * @returns A list of competition progress objects, including the player and their value history over time.
     */
    getCompetitionTopHistory(id: number, previewMetric?: Metric): Promise<ParticipantHistoryResponse[]>;
    /**
     * Creates a new competition.
     * @returns The newly created competition, and the verification code that authorizes future changes to it.
     */
    createCompetition(payload: CreateCompetitionPayload): Promise<{
        competition: CompetitionDetailsResponse;
        verificationCode: string;
    }>;
    /**
     * Edits an existing competition.
     * @returns The updated competition.
     */
    editCompetition(id: number, payload: EditCompetitionPayload, verificationCode: string): Promise<CompetitionDetailsResponse>;
    /**
     * Deletes an existing competition.
     * @returns A confirmation message.
     */
    deleteCompetition(id: number, verificationCode: string): Promise<GenericMessageResponse>;
    /**
     * Adds all (valid) given participants to a competition, ignoring duplicates.
     * @returns The number of participants added and a confirmation message.
     */
    addParticipants(id: number, participants: string[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Remove all given usernames from a competition, ignoring usernames that aren't competing.
     * @returns The number of participants removed and a confirmation message.
     */
    removeParticipants(id: number, participants: string[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Adds all (valid) given teams to a team competition, ignoring duplicates.
     * @returns The number of participants added and a confirmation message.
     */
    addTeams(id: number, teams: CompetitionTeam[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Remove all given team names from a competition, ignoring names that don't exist.
     * @returns The number of participants removed and a confirmation message.
     */
    removeTeams(id: number, teamNames: string[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Adds an "update" request to the queue, for each outdated competition participant.
     * @returns The number of players to be updated and a confirmation message.
     */
    updateAll(id: number, verificationCode: string): Promise<GenericCountMessageResponse>;
}

declare class DeltasClient extends BaseAPIClient {
    /**
     * Fetches the current top leaderboard for a specific metric, period, playerType, playerBuild and country.
     * @returns A list of deltas, with their respective players, values and dates included.
     */
    getDeltaLeaderboard(filter: {
        country?: Country;
        playerType?: PlayerType;
        playerBuild?: PlayerBuild;
        metric: Metric;
        period: Period | string;
    }): Promise<{
        player: PlayerResponse;
        startDate: Date;
        endDate: Date;
        gained: number;
    }[]>;
}

declare class EfficiencyClient extends BaseAPIClient {
    /**
     * Fetches the current efficiency leaderboard for a specific efficiency metric, playerType, playerBuild and country.
     * @returns A list of players.
     */
    getEfficiencyLeaderboards(filter: {
        country?: Country;
        playerType?: PlayerType;
        playerBuild?: PlayerBuild;
        metric: typeof Metric.EHP | typeof Metric.EHB | 'ehp+ehb';
    }, pagination?: PaginationOptions): Promise<PlayerResponse[]>;
    /**
     * Fetches the top EHP (Efficient Hours Played) rates.
     * @returns A list of skilling methods and their bonus exp ratios.
     */
    getEHPRates(algorithmType: `${EfficiencyAlgorithmType}`): Promise<SkillMetaConfig[]>;
    /**
     * Fetches the top EHB (Efficient Hours Bossed) rates.
     * @returns A list of bosses and their respective "per-hour" kill rates.
     */
    getEHBRates(algorithmType: `${EfficiencyAlgorithmType}`): Promise<BossMetaConfig[]>;
}

declare class GroupsClient extends BaseAPIClient {
    /**
     * Searches for groups that match a partial name.
     * @returns A list of groups.
     */
    searchGroups(name: string, pagination?: PaginationOptions): Promise<GroupResponse[]>;
    /**
     * Fetches a group's details, including a list of membership objects.
     * @returns A group details object.
     */
    getGroupDetails(id: number): Promise<GroupDetailsResponse>;
    /**
     * Creates a new group.
     * @returns The newly created group, and the verification code that authorizes future changes to it.
     */
    createGroup(payload: CreateGroupPayload): Promise<{
        group: GroupDetailsResponse;
        verificationCode: string;
    }>;
    /**
     * Edits an existing group.
     * @returns The updated group.
     */
    editGroup(id: number, payload: EditGroupPayload, verificationCode: string): Promise<GroupDetailsResponse>;
    /**
     * Deletes an existing group.
     * @returns A confirmation message.
     */
    deleteGroup(id: number, verificationCode: string): Promise<GenericMessageResponse>;
    /**
     * Adds all (valid) given usernames (and roles) to a group, ignoring duplicates.
     * @returns The number of members added and a confirmation message.
     */
    addMembers(id: number, members: Array<{
        username: string;
        role?: GroupRole;
    }>, verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Remove all given usernames from a group, ignoring usernames that aren't members.
     * @returns The number of members removed and a confirmation message.
     */
    removeMembers(id: number, usernames: string[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Changes a player's role in a given group.
     * @returns The updated membership, with player included.
     */
    changeRole(id: number, payload: {
        username: string;
        role: GroupRole;
    }, verificationCode: string): Promise<Membership & {
        player: PlayerResponse;
    }>;
    /**
     * Adds an "update" request to the queue, for each outdated group member.
     * @returns The number of players to be updated and a confirmation message.
     */
    updateAll(id: number, verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Fetches all of the groups's competitions
     * @returns A list of competitions.
     */
    getGroupCompetitions(id: number, pagination?: PaginationOptions): Promise<CompetitionResponse[]>;
    getGroupGains(id: number, filter: TimeRangeFilter & {
        metric: Metric;
    }, pagination?: PaginationOptions): Promise<{
        player: PlayerResponse;
        startDate: Date;
        endDate: Date;
        data: MetricDelta;
    }[]>;
    /**
     * Fetches a group members' latest achievements.
     * @returns A list of achievements.
     */
    getGroupAchievements(id: number, pagination?: PaginationOptions): Promise<(AchievementResponse & {
        player: PlayerResponse;
    })[]>;
    /**
     * Fetches a group's record leaderboard for a specific metric and period.
     * @returns A list of records, including their respective players.
     */
    getGroupRecords(id: number, filter: {
        metric: Metric;
        period: Period;
    }, pagination?: PaginationOptions): Promise<(Record$1 & {
        player: PlayerResponse;
    })[]>;
    /**
     * Fetches a group's hiscores for a specific metric.
     * @returns A list of hiscores entries (value, rank), including their respective players.
     */
    getGroupHiscores(id: number, metric: Metric, pagination?: PaginationOptions): Promise<GroupHiscoresEntryResponse[]>;
    /**
     * Fetches a group members' latest name changes.
     * @returns A list of name change (approved) requests.
     */
    getGroupNameChanges(id: number, pagination?: PaginationOptions): Promise<(NameChange & {
        player: PlayerResponse;
    })[]>;
    /**
     * Fetches a group's general statistics.
     * @returns An object with a few statistic values and an average stats snapshot.
     */
    getGroupStatistics(id: number): Promise<GroupStatisticsResponse>;
    /**
     * Fetches a group's activity.
     * @returns A list of a group's (join, leave and role changed) activity.
     */
    getGroupActivity(id: number, pagination?: PaginationOptions): Promise<(MemberActivity & {
        player: PlayerResponse;
    })[]>;
    /**
     * Fetches the groups's member list in CSV format.
     * @returns A string containing the CSV content.
     */
    getMembersCSV(id: number): Promise<string>;
}

declare class NameChangesClient extends BaseAPIClient {
    /**
     * Searches for name changes that match a name and/or status filter.
     * @returns A list of name changes.
     */
    searchNameChanges(filter: {
        username?: string;
        status?: NameChangeStatus;
    }, pagination?: PaginationOptions): Promise<NameChange[]>;
    /**
     * Submits a name change request between two usernames (old and new).
     * @returns A pending name change request, to be reviewed and resolved at a later date.
     */
    submitNameChange(oldName: string, newName: string): Promise<NameChange>;
}

declare class PlayersClient extends BaseAPIClient {
    /**
     * Searches players by partial username.
     * @returns A list of players.
     */
    searchPlayers(partialUsername: string, pagination?: PaginationOptions): Promise<PlayerResponse[]>;
    /**
     * Updates/tracks a player.
     * @returns The player's new details, including the latest snapshot.
     */
    updatePlayer(username: string): Promise<PlayerDetailsResponse>;
    /**
     * Asserts (and attempts to fix, if necessary) a player's game-mode type.
     * @returns The updated player, and an indication of whether the type was changed.
     */
    assertPlayerType(username: string): Promise<{
        player: PlayerResponse;
        changed: boolean;
    }>;
    /**
     * Fetches a player's details.
     * @returns The player's details, including the latest snapshot.
     */
    getPlayerDetails(username: string): Promise<PlayerDetailsResponse>;
    /**
     * Fetches a player's details by ID.
     * @returns The player's details, including the latest snapshot.
     */
    getPlayerDetailsById(id: number): Promise<PlayerDetailsResponse>;
    /**
     * Fetches a player's current achievements.
     * @returns A list of achievements.
     */
    getPlayerAchievements(username: string): Promise<AchievementResponse[]>;
    /**
     * Fetches a player's current achievement progress.
     * @returns A list of achievements (completed or otherwise), with their respective relative/absolute progress percentage.
     */
    getPlayerAchievementProgress(username: string): Promise<AchievementProgressResponse[]>;
    /**
     * Fetches all of the player's competition participations.
     * @returns A list of participations, with the respective competition included.
     */
    getPlayerCompetitions(username: string, filter?: {
        status?: CompetitionStatus;
    }, pagination?: PaginationOptions): Promise<(ParticipationResponse & {
        competition: CompetitionResponse;
    })[]>;
    /**
     * Fetches all of the player's competition participations' standings.
     * @returns A list of participations, with the respective competition, rank and progress included.
     */
    getPlayerCompetitionStandings(username: string, filter: {
        status?: CompetitionStatus;
    }): Promise<PlayerCompetitionStandingResponse[]>;
    /**
     * Fetches all of the player's group memberships.
     * @returns A list of memberships, with the respective group included.
     */
    getPlayerGroups(username: string, pagination?: PaginationOptions): Promise<(Membership & {
        group: GroupResponse;
    })[]>;
    /**
     * Fetches a player's gains, for a specific period or time range, as a [metric: data] map.
     * @returns A map of each metric's gained data.
     */
    getPlayerGains(username: string, options: TimeRangeFilter): Promise<{
        startsAt: Date | null;
        endsAt: Date | null;
        data: PlayerDeltasMapResponse;
    }>;
    /**
     * Fetches all of the player's records.
     * @returns A list of records.
     */
    getPlayerRecords(username: string, options?: {
        period: Period | string;
        metric: Metric;
    }): Promise<Record$1[]>;
    /**
     * Fetches all of the player's past snapshots.
     * @returns A list of snapshots.
     */
    getPlayerSnapshots(username: string, filter: TimeRangeFilter, pagination?: PaginationOptions): Promise<SnapshotResponse[]>;
    /**
     * Fetches all of the player's past snapshots' timeline.
     * @returns A list of timeseries data (value, rank, date)
     */
    getPlayerSnapshotTimeline(username: string, metric: Metric, options?: TimeRangeFilter): Promise<{
        value: number;
        rank: number;
        date: Date;
    }[]>;
    /**
     * Fetches all of the player's approved name changes.
     * @returns A list of name changes.
     */
    getPlayerNames(username: string): Promise<NameChange[]>;
    /**
     * Fetches all of archived players that previously held this username.
     * @returns A list of player archives.
     */
    getPlayerArchives(username: string): Promise<(PlayerArchive & {
        player: PlayerResponse;
    })[]>;
}

declare class RecordsClient extends BaseAPIClient {
    /**
     * Fetches the current records leaderboard for a specific metric, period, playerType, playerBuild and country.
     * @returns A list of records, with their respective players, dates and values included.
     */
    getRecordLeaderboard(filter: {
        country?: Country;
        playerType?: PlayerType;
        playerBuild?: PlayerBuild;
        metric: Metric;
        period: Period;
    }): Promise<(Record$1 & {
        player: PlayerResponse;
    })[]>;
}

interface WOMClientOptions {
    apiKey?: string;
    userAgent?: string;
    baseAPIUrl?: string;
}
declare class WOMClient extends BaseAPIClient {
    deltas: DeltasClient;
    groups: GroupsClient;
    players: PlayersClient;
    records: RecordsClient;
    efficiency: EfficiencyClient;
    nameChanges: NameChangesClient;
    competitions: CompetitionsClient;
    constructor(options?: WOMClientOptions);
}

declare const CompetitionStatusProps: Record<CompetitionStatus, {
    name: string;
}>;

declare const CompetitionTypeProps: Record<CompetitionType, {
    name: string;
}>;

declare const CountryProps: Record<Country, {
    code: Country;
    name: string;
}>;
declare function isCountry(countryCodeString: string): countryCodeString is Country;
declare function findCountry(countryIdentifier: string): {
    code: Country;
    name: string;
};
declare function findCountryByName(countryName: string): {
    code: Country;
    name: string;
};
declare function findCountryByCode(countryCode: string): {
    code: Country;
    name: string;
};

declare const MAX_LEVEL = 99;
declare const MAX_VIRTUAL_LEVEL = 126;
declare const MAX_SKILL_EXP = 200000000;
declare const SKILL_EXP_AT_99 = 13034431;
declare const CAPPED_MAX_TOTAL_XP: number;
declare function getExpForLevel(level: number): number;
declare function getLevel(exp: number, virtual?: boolean): number;
declare function getCombatLevel(attack: number, strength: number, defence: number, ranged: number, magic: number, hitpoints: number, prayer: number): number;

declare function formatNumber(num: number, withLetters?: boolean, decimalPrecision?: number): string | -1;

declare const GroupRoleProps: {
    achiever: {
        name: string;
    };
    adamant: {
        name: string;
    };
    adept: {
        name: string;
    };
    administrator: {
        name: string;
    };
    admiral: {
        name: string;
    };
    adventurer: {
        name: string;
    };
    air: {
        name: string;
    };
    anchor: {
        name: string;
    };
    apothecary: {
        name: string;
    };
    archer: {
        name: string;
    };
    armadylean: {
        name: string;
    };
    artillery: {
        name: string;
    };
    artisan: {
        name: string;
    };
    asgarnian: {
        name: string;
    };
    assassin: {
        name: string;
    };
    assistant: {
        name: string;
    };
    astral: {
        name: string;
    };
    athlete: {
        name: string;
    };
    attacker: {
        name: string;
    };
    bandit: {
        name: string;
    };
    bandosian: {
        name: string;
    };
    barbarian: {
        name: string;
    };
    battlemage: {
        name: string;
    };
    beast: {
        name: string;
    };
    berserker: {
        name: string;
    };
    blisterwood: {
        name: string;
    };
    blood: {
        name: string;
    };
    blue: {
        name: string;
    };
    bob: {
        name: string;
    };
    body: {
        name: string;
    };
    brassican: {
        name: string;
    };
    brawler: {
        name: string;
    };
    brigadier: {
        name: string;
    };
    brigand: {
        name: string;
    };
    bronze: {
        name: string;
    };
    bruiser: {
        name: string;
    };
    bulwark: {
        name: string;
    };
    burglar: {
        name: string;
    };
    burnt: {
        name: string;
    };
    cadet: {
        name: string;
    };
    captain: {
        name: string;
    };
    carry: {
        name: string;
    };
    champion: {
        name: string;
    };
    chaos: {
        name: string;
    };
    cleric: {
        name: string;
    };
    collector: {
        name: string;
    };
    colonel: {
        name: string;
    };
    commander: {
        name: string;
    };
    competitor: {
        name: string;
    };
    completionist: {
        name: string;
    };
    constructor: {
        name: string;
    };
    cook: {
        name: string;
    };
    coordinator: {
        name: string;
    };
    corporal: {
        name: string;
    };
    cosmic: {
        name: string;
    };
    councillor: {
        name: string;
    };
    crafter: {
        name: string;
    };
    crew: {
        name: string;
    };
    crusader: {
        name: string;
    };
    cutpurse: {
        name: string;
    };
    death: {
        name: string;
    };
    defender: {
        name: string;
    };
    defiler: {
        name: string;
    };
    deputy_owner: {
        name: string;
    };
    destroyer: {
        name: string;
    };
    diamond: {
        name: string;
    };
    diseased: {
        name: string;
    };
    doctor: {
        name: string;
    };
    dogsbody: {
        name: string;
    };
    dragon: {
        name: string;
    };
    dragonstone: {
        name: string;
    };
    druid: {
        name: string;
    };
    duellist: {
        name: string;
    };
    earth: {
        name: string;
    };
    elite: {
        name: string;
    };
    emerald: {
        name: string;
    };
    enforcer: {
        name: string;
    };
    epic: {
        name: string;
    };
    executive: {
        name: string;
    };
    expert: {
        name: string;
    };
    explorer: {
        name: string;
    };
    farmer: {
        name: string;
    };
    feeder: {
        name: string;
    };
    fighter: {
        name: string;
    };
    fire: {
        name: string;
    };
    firemaker: {
        name: string;
    };
    firestarter: {
        name: string;
    };
    fisher: {
        name: string;
    };
    fletcher: {
        name: string;
    };
    forager: {
        name: string;
    };
    fremennik: {
        name: string;
    };
    gamer: {
        name: string;
    };
    gatherer: {
        name: string;
    };
    general: {
        name: string;
    };
    gnome_child: {
        name: string;
    };
    gnome_elder: {
        name: string;
    };
    goblin: {
        name: string;
    };
    gold: {
        name: string;
    };
    goon: {
        name: string;
    };
    green: {
        name: string;
    };
    grey: {
        name: string;
    };
    guardian: {
        name: string;
    };
    guthixian: {
        name: string;
    };
    harpoon: {
        name: string;
    };
    healer: {
        name: string;
    };
    hellcat: {
        name: string;
    };
    helper: {
        name: string;
    };
    herbologist: {
        name: string;
    };
    hero: {
        name: string;
    };
    holy: {
        name: string;
    };
    hoarder: {
        name: string;
    };
    hunter: {
        name: string;
    };
    ignitor: {
        name: string;
    };
    illusionist: {
        name: string;
    };
    imp: {
        name: string;
    };
    infantry: {
        name: string;
    };
    inquisitor: {
        name: string;
    };
    iron: {
        name: string;
    };
    jade: {
        name: string;
    };
    justiciar: {
        name: string;
    };
    kandarin: {
        name: string;
    };
    karamjan: {
        name: string;
    };
    kharidian: {
        name: string;
    };
    kitten: {
        name: string;
    };
    knight: {
        name: string;
    };
    labourer: {
        name: string;
    };
    law: {
        name: string;
    };
    leader: {
        name: string;
    };
    learner: {
        name: string;
    };
    legacy: {
        name: string;
    };
    legend: {
        name: string;
    };
    legionnaire: {
        name: string;
    };
    lieutenant: {
        name: string;
    };
    looter: {
        name: string;
    };
    lumberjack: {
        name: string;
    };
    magic: {
        name: string;
    };
    magician: {
        name: string;
    };
    major: {
        name: string;
    };
    maple: {
        name: string;
    };
    marshal: {
        name: string;
    };
    master: {
        name: string;
    };
    maxed: {
        name: string;
    };
    mediator: {
        name: string;
    };
    medic: {
        name: string;
    };
    mentor: {
        name: string;
    };
    member: {
        name: string;
    };
    merchant: {
        name: string;
    };
    mind: {
        name: string;
    };
    miner: {
        name: string;
    };
    minion: {
        name: string;
    };
    misthalinian: {
        name: string;
    };
    mithril: {
        name: string;
    };
    moderator: {
        name: string;
    };
    monarch: {
        name: string;
    };
    morytanian: {
        name: string;
    };
    mystic: {
        name: string;
    };
    myth: {
        name: string;
    };
    natural: {
        name: string;
    };
    nature: {
        name: string;
    };
    necromancer: {
        name: string;
    };
    ninja: {
        name: string;
    };
    noble: {
        name: string;
    };
    novice: {
        name: string;
    };
    nurse: {
        name: string;
    };
    oak: {
        name: string;
    };
    officer: {
        name: string;
    };
    onyx: {
        name: string;
    };
    opal: {
        name: string;
    };
    oracle: {
        name: string;
    };
    orange: {
        name: string;
    };
    owner: {
        name: string;
    };
    page: {
        name: string;
    };
    paladin: {
        name: string;
    };
    pawn: {
        name: string;
    };
    pilgrim: {
        name: string;
    };
    pine: {
        name: string;
    };
    pink: {
        name: string;
    };
    prefect: {
        name: string;
    };
    priest: {
        name: string;
    };
    private: {
        name: string;
    };
    prodigy: {
        name: string;
    };
    proselyte: {
        name: string;
    };
    prospector: {
        name: string;
    };
    protector: {
        name: string;
    };
    pure: {
        name: string;
    };
    purple: {
        name: string;
    };
    pyromancer: {
        name: string;
    };
    quester: {
        name: string;
    };
    racer: {
        name: string;
    };
    raider: {
        name: string;
    };
    ranger: {
        name: string;
    };
    record_chaser: {
        name: string;
    };
    recruit: {
        name: string;
    };
    recruiter: {
        name: string;
    };
    red_topaz: {
        name: string;
    };
    red: {
        name: string;
    };
    rogue: {
        name: string;
    };
    ruby: {
        name: string;
    };
    rune: {
        name: string;
    };
    runecrafter: {
        name: string;
    };
    sage: {
        name: string;
    };
    sapphire: {
        name: string;
    };
    saradominist: {
        name: string;
    };
    saviour: {
        name: string;
    };
    scavenger: {
        name: string;
    };
    scholar: {
        name: string;
    };
    scourge: {
        name: string;
    };
    scout: {
        name: string;
    };
    scribe: {
        name: string;
    };
    seer: {
        name: string;
    };
    senator: {
        name: string;
    };
    sentry: {
        name: string;
    };
    serenist: {
        name: string;
    };
    sergeant: {
        name: string;
    };
    shaman: {
        name: string;
    };
    sheriff: {
        name: string;
    };
    short_green_guy: {
        name: string;
    };
    skiller: {
        name: string;
    };
    skulled: {
        name: string;
    };
    slayer: {
        name: string;
    };
    smiter: {
        name: string;
    };
    smith: {
        name: string;
    };
    smuggler: {
        name: string;
    };
    sniper: {
        name: string;
    };
    soul: {
        name: string;
    };
    specialist: {
        name: string;
    };
    speed_runner: {
        name: string;
    };
    spellcaster: {
        name: string;
    };
    squire: {
        name: string;
    };
    staff: {
        name: string;
    };
    steel: {
        name: string;
    };
    strider: {
        name: string;
    };
    striker: {
        name: string;
    };
    summoner: {
        name: string;
    };
    superior: {
        name: string;
    };
    supervisor: {
        name: string;
    };
    teacher: {
        name: string;
    };
    templar: {
        name: string;
    };
    therapist: {
        name: string;
    };
    thief: {
        name: string;
    };
    tirannian: {
        name: string;
    };
    trialist: {
        name: string;
    };
    trickster: {
        name: string;
    };
    tzkal: {
        name: string;
    };
    tztok: {
        name: string;
    };
    unholy: {
        name: string;
    };
    vagrant: {
        name: string;
    };
    vanguard: {
        name: string;
    };
    walker: {
        name: string;
    };
    wanderer: {
        name: string;
    };
    warden: {
        name: string;
    };
    warlock: {
        name: string;
    };
    warrior: {
        name: string;
    };
    water: {
        name: string;
    };
    wild: {
        name: string;
    };
    willow: {
        name: string;
    };
    wily: {
        name: string;
    };
    wintumber: {
        name: string;
    };
    witch: {
        name: string;
    };
    wizard: {
        name: string;
    };
    worker: {
        name: string;
    };
    wrath: {
        name: string;
    };
    xerician: {
        name: string;
    };
    yellow: {
        name: string;
    };
    yew: {
        name: string;
    };
    zamorakian: {
        name: string;
    };
    zarosian: {
        name: string;
    };
    zealot: {
        name: string;
    };
    zenyte: {
        name: string;
    };
};
declare function isGroupRole(roleString: string): roleString is GroupRole;
declare const PRIVILEGED_GROUP_ROLES: readonly ["administrator", "owner", "leader", "deputy_owner", "moderator"];

declare const SkillProps: Record<Skill, {
    name: string;
    isCombat: boolean;
    isMembers: boolean;
    type: MetricType;
    measure: MetricMeasure;
}>;
declare const BossProps: Record<Boss, {
    name: string;
    minimumValue: number;
    isMembers: boolean;
    type: MetricType;
    measure: MetricMeasure;
}>;
declare const ActivityProps: Record<Activity, {
    name: string;
    minimumValue: number;
    type: MetricType;
    measure: MetricMeasure;
}>;
declare const ComputedMetricProps: Record<ComputedMetric, {
    name: string;
    type: MetricType;
    measure: MetricMeasure;
}>;
declare const MetricProps: {
    readonly ehp: {
        name: string;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly ehb: {
        name: string;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly league_points: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly bounty_hunter_hunter: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly bounty_hunter_rogue: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly clue_scrolls_all: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly clue_scrolls_beginner: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly clue_scrolls_easy: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly clue_scrolls_medium: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly clue_scrolls_hard: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly clue_scrolls_elite: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly clue_scrolls_master: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly last_man_standing: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly pvp_arena: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly soul_wars_zeal: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly guardians_of_the_rift: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly colosseum_glory: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly collections_logged: {
        name: string;
        minimumValue: number;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly abyssal_sire: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly alchemical_hydra: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly amoxliatl: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly araxxor: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly artio: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly barrows_chests: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly bryophyta: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly callisto: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly calvarion: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly cerberus: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly chambers_of_xeric: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly chambers_of_xeric_challenge_mode: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly chaos_elemental: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly chaos_fanatic: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly commander_zilyana: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly corporeal_beast: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly crazy_archaeologist: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly dagannoth_prime: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly dagannoth_rex: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly dagannoth_supreme: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly deranged_archaeologist: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly doom_of_mokhaiotl: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly duke_sucellus: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly general_graardor: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly giant_mole: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly grotesque_guardians: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly hespori: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly kalphite_queen: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly king_black_dragon: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly kraken: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly kreearra: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly kril_tsutsaroth: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly lunar_chests: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly mimic: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly nex: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly nightmare: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly phosanis_nightmare: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly obor: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly phantom_muspah: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly sarachnis: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly scorpia: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly scurrius: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly skotizo: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly sol_heredit: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly spindel: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly tempoross: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly the_gauntlet: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly the_corrupted_gauntlet: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly the_hueycoatl: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly the_leviathan: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly the_royal_titans: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly the_whisperer: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly theatre_of_blood: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly theatre_of_blood_hard_mode: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly thermonuclear_smoke_devil: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly tombs_of_amascut: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly tombs_of_amascut_expert: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly tzkal_zuk: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly tztok_jad: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly vardorvis: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly venenatis: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly vetion: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly vorkath: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly wintertodt: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly yama: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly zalcano: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly zulrah: {
        name: string;
        minimumValue: number;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly overall: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly attack: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly defence: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly strength: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly hitpoints: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly ranged: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly prayer: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly magic: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly cooking: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly woodcutting: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly fletching: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly fishing: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly firemaking: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly crafting: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly smithing: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly mining: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly herblore: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly agility: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly thieving: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly slayer: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly farming: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly runecrafting: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly hunter: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
    readonly construction: {
        name: string;
        isCombat: boolean;
        isMembers: boolean;
        type: MetricType;
        measure: MetricMeasure;
    };
};
declare const REAL_SKILLS: Skill[];
declare const F2P_BOSSES: Boss[];
declare const MEMBER_SKILLS: Skill[];
declare const COMBAT_SKILLS: Skill[];
declare const REAL_METRICS: (Skill | Activity | Boss)[];
declare function isMetric(metric: Metric | string): metric is Metric;
declare function isSkill(metric: Metric | string): metric is Skill;
declare function isActivity(metric: Metric | string): metric is Activity;
declare function isBoss(metric: Metric | string): metric is Boss;
declare function isComputedMetric(metric: Metric | string): metric is ComputedMetric;
declare function getMinimumValue(metric: Metric): number;
declare function getParentEfficiencyMetric(metric: Metric): "ehp" | "ehb";

declare function padNumber(value: number): string;

declare function parsePeriodExpression(periodExpression: string): {
    expression: string;
    durationMs: number;
};

declare const PeriodProps: Record<Period, {
    name: string;
    milliseconds: number;
}>;
declare function isPeriod(periodString: string): periodString is Period;

declare const PlayerBuildProps: Record<PlayerBuild, {
    name: string;
}>;
declare function isPlayerBuild(buildString: string): buildString is PlayerBuild;

declare const PlayerStatusProps: Record<PlayerStatus, {
    name: string;
}>;
declare function isPlayerStatus(statusString: string): statusString is PlayerStatus;

declare const PlayerTypeProps: Record<PlayerType, {
    name: string;
}>;
declare function isPlayerType(typeString: string): typeString is PlayerType;

declare function roundNumber(num: number, cases: number): number;

export { ACTIVITIES, type Achievement, type AchievementDefinition, type AchievementMeasure, type AchievementProgressResponse, type AchievementResponse, Activity, ActivityProps, BOSSES, Boss, type BossMetaConfig, BossProps, CAPPED_MAX_TOTAL_XP, COMBAT_SKILLS, COMPETITION_STATUSES, COMPETITION_TYPES, COMPUTED_METRICS, COUNTRY_CODES, type CachedDelta, type Competition, CompetitionCSVTableType, type CompetitionDetailsResponse, type CompetitionMetric, type CompetitionResponse, CompetitionStatus, CompetitionStatusProps, type CompetitionTeam, CompetitionType, CompetitionTypeProps, ComputedMetric, ComputedMetricProps, Country, CountryProps, type CreateCompetitionPayload, type CreateGroupPayload, type Delta, type EditCompetitionPayload, type EditGroupPayload, EfficiencyAlgorithmType, F2P_BOSSES, GROUP_ROLES, type GenericCountMessageResponse, type GenericMessageResponse, type Group, type GroupDetailsResponse, type GroupHiscoresEntryResponse, type GroupResponse, GroupRole, type GroupRoleOrder, GroupRoleProps, type GroupSocialLinks, type GroupStatisticsResponse, MAX_LEVEL, MAX_SKILL_EXP, MAX_VIRTUAL_LEVEL, MEMBER_SKILLS, METRICS, type MemberActivity, type MemberActivityResponse, MemberActivityType, type Membership, type MembershipResponse, Metric, type MetricDelta, MetricMeasure, MetricProps, MetricType, type NameChange, type NameChangeDenyContext, type NameChangeDetailsResponse, type NameChangeResponse, type NameChangeReviewContext, type NameChangeSkipContext, NameChangeStatus, PERIODS, PLAYER_BUILDS, PLAYER_STATUSES, PLAYER_TYPES, PRIVILEGED_GROUP_ROLES, type ParticipantHistoryResponse, type Participation, type ParticipationResponse, type Patron, Period, PeriodProps, type Player, type PlayerAnnotation, PlayerAnnotationType, type PlayerArchive, type PlayerArchiveResponse, PlayerBuild, PlayerBuildProps, type PlayerCompetitionStandingResponse, type PlayerDeltasMapResponse, type PlayerDetailsResponse, type PlayerResponse, PlayerStatus, PlayerStatusProps, PlayerType, PlayerTypeProps, REAL_METRICS, REAL_SKILLS, type Record$1 as Record, type RecordResponse, SKILLS, SKILL_EXP_AT_99, Skill, type SkillMetaBonus, type SkillMetaConfig, type SkillMetaMethod, SkillProps, type Snapshot, type SnapshotResponse, type TimeRangeFilter, WOMClient, findCountry, findCountryByCode, findCountryByName, formatNumber, getCombatLevel, getExpForLevel, getLevel, getMinimumValue, getParentEfficiencyMetric, isActivity, isBoss, isComputedMetric, isCountry, isGroupRole, isMetric, isPeriod, isPlayerBuild, isPlayerStatus, isPlayerType, isSkill, padNumber, parsePeriodExpression, roundNumber };
